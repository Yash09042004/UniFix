{"ast":null,"code":"/**\n * Encodes an RGBA image to a ThumbHash. RGB should not be premultiplied by A.\n *\n * @param w The width of the input image. Must be ≤100px.\n * @param h The height of the input image. Must be ≤100px.\n * @param rgba The pixels in the input image, row-by-row. Must have w*h*4 elements.\n * @returns The ThumbHash as a Uint8Array.\n */\nexport function rgbaToThumbHash(w, h, rgba) {\n  // Encoding an image larger than 100x100 is slow with no benefit\n  if (w > 100 || h > 100) throw new Error(`${w}x${h} doesn't fit in 100x100`);\n  let {\n    PI,\n    round,\n    max,\n    cos,\n    abs\n  } = Math;\n\n  // Determine the average color\n  let avg_r = 0,\n    avg_g = 0,\n    avg_b = 0,\n    avg_a = 0;\n  for (let i = 0, j = 0; i < w * h; i++, j += 4) {\n    let alpha = rgba[j + 3] / 255;\n    avg_r += alpha / 255 * rgba[j];\n    avg_g += alpha / 255 * rgba[j + 1];\n    avg_b += alpha / 255 * rgba[j + 2];\n    avg_a += alpha;\n  }\n  if (avg_a) {\n    avg_r /= avg_a;\n    avg_g /= avg_a;\n    avg_b /= avg_a;\n  }\n  let hasAlpha = avg_a < w * h;\n  let l_limit = hasAlpha ? 5 : 7; // Use fewer luminance bits if there's alpha\n  let lx = max(1, round(l_limit * w / max(w, h)));\n  let ly = max(1, round(l_limit * h / max(w, h)));\n  let l = []; // luminance\n  let p = []; // yellow - blue\n  let q = []; // red - green\n  let a = []; // alpha\n\n  // Convert the image from RGBA to LPQA (composite atop the average color)\n  for (let i = 0, j = 0; i < w * h; i++, j += 4) {\n    let alpha = rgba[j + 3] / 255;\n    let r = avg_r * (1 - alpha) + alpha / 255 * rgba[j];\n    let g = avg_g * (1 - alpha) + alpha / 255 * rgba[j + 1];\n    let b = avg_b * (1 - alpha) + alpha / 255 * rgba[j + 2];\n    l[i] = (r + g + b) / 3;\n    p[i] = (r + g) / 2 - b;\n    q[i] = r - g;\n    a[i] = alpha;\n  }\n\n  // Encode using the DCT into DC (constant) and normalized AC (varying) terms\n  let encodeChannel = (channel, nx, ny) => {\n    let dc = 0,\n      ac = [],\n      scale = 0,\n      fx = [];\n    for (let cy = 0; cy < ny; cy++) {\n      for (let cx = 0; cx * ny < nx * (ny - cy); cx++) {\n        let f = 0;\n        for (let x = 0; x < w; x++) fx[x] = cos(PI / w * cx * (x + 0.5));\n        for (let y = 0; y < h; y++) for (let x = 0, fy = cos(PI / h * cy * (y + 0.5)); x < w; x++) f += channel[x + y * w] * fx[x] * fy;\n        f /= w * h;\n        if (cx || cy) {\n          ac.push(f);\n          scale = max(scale, abs(f));\n        } else {\n          dc = f;\n        }\n      }\n    }\n    if (scale) for (let i = 0; i < ac.length; i++) ac[i] = 0.5 + 0.5 / scale * ac[i];\n    return [dc, ac, scale];\n  };\n  let [l_dc, l_ac, l_scale] = encodeChannel(l, max(3, lx), max(3, ly));\n  let [p_dc, p_ac, p_scale] = encodeChannel(p, 3, 3);\n  let [q_dc, q_ac, q_scale] = encodeChannel(q, 3, 3);\n  let [a_dc, a_ac, a_scale] = hasAlpha ? encodeChannel(a, 5, 5) : [];\n\n  // Write the constants\n  let isLandscape = w > h;\n  let header24 = round(63 * l_dc) | round(31.5 + 31.5 * p_dc) << 6 | round(31.5 + 31.5 * q_dc) << 12 | round(31 * l_scale) << 18 | hasAlpha << 23;\n  let header16 = (isLandscape ? ly : lx) | round(63 * p_scale) << 3 | round(63 * q_scale) << 9 | isLandscape << 15;\n  let hash = [header24 & 255, header24 >> 8 & 255, header24 >> 16, header16 & 255, header16 >> 8];\n  let ac_start = hasAlpha ? 6 : 5;\n  let ac_index = 0;\n  if (hasAlpha) hash.push(round(15 * a_dc) | round(15 * a_scale) << 4);\n\n  // Write the varying factors\n  for (let ac of hasAlpha ? [l_ac, p_ac, q_ac, a_ac] : [l_ac, p_ac, q_ac]) for (let f of ac) hash[ac_start + (ac_index >> 1)] |= round(15 * f) << ((ac_index++ & 1) << 2);\n  return new Uint8Array(hash);\n}\n\n/**\n * Decodes a ThumbHash to an RGBA image. RGB is not be premultiplied by A.\n *\n * @param hash The bytes of the ThumbHash.\n * @returns The width, height, and pixels of the rendered placeholder image.\n */\nexport function thumbHashToRGBA(hash) {\n  let {\n    PI,\n    min,\n    max,\n    cos,\n    round\n  } = Math;\n\n  // Read the constants\n  let header24 = hash[0] | hash[1] << 8 | hash[2] << 16;\n  let header16 = hash[3] | hash[4] << 8;\n  let l_dc = (header24 & 63) / 63;\n  let p_dc = (header24 >> 6 & 63) / 31.5 - 1;\n  let q_dc = (header24 >> 12 & 63) / 31.5 - 1;\n  let l_scale = (header24 >> 18 & 31) / 31;\n  let hasAlpha = header24 >> 23;\n  let p_scale = (header16 >> 3 & 63) / 63;\n  let q_scale = (header16 >> 9 & 63) / 63;\n  let isLandscape = header16 >> 15;\n  let lx = max(3, isLandscape ? hasAlpha ? 5 : 7 : header16 & 7);\n  let ly = max(3, isLandscape ? header16 & 7 : hasAlpha ? 5 : 7);\n  let a_dc = hasAlpha ? (hash[5] & 15) / 15 : 1;\n  let a_scale = (hash[5] >> 4) / 15;\n\n  // Read the varying factors (boost saturation by 1.25x to compensate for quantization)\n  let ac_start = hasAlpha ? 6 : 5;\n  let ac_index = 0;\n  let decodeChannel = (nx, ny, scale) => {\n    let ac = [];\n    for (let cy = 0; cy < ny; cy++) for (let cx = cy ? 0 : 1; cx * ny < nx * (ny - cy); cx++) ac.push(((hash[ac_start + (ac_index >> 1)] >> ((ac_index++ & 1) << 2) & 15) / 7.5 - 1) * scale);\n    return ac;\n  };\n  let l_ac = decodeChannel(lx, ly, l_scale);\n  let p_ac = decodeChannel(3, 3, p_scale * 1.25);\n  let q_ac = decodeChannel(3, 3, q_scale * 1.25);\n  let a_ac = hasAlpha && decodeChannel(5, 5, a_scale);\n\n  // Decode using the DCT into RGB\n  let ratio = thumbHashToApproximateAspectRatio(hash);\n  let w = round(ratio > 1 ? 32 : 32 * ratio);\n  let h = round(ratio > 1 ? 32 / ratio : 32);\n  let rgba = new Uint8Array(w * h * 4),\n    fx = [],\n    fy = [];\n  for (let y = 0, i = 0; y < h; y++) {\n    for (let x = 0; x < w; x++, i += 4) {\n      let l = l_dc,\n        p = p_dc,\n        q = q_dc,\n        a = a_dc;\n\n      // Precompute the coefficients\n      for (let cx = 0, n = max(lx, hasAlpha ? 5 : 3); cx < n; cx++) fx[cx] = cos(PI / w * (x + 0.5) * cx);\n      for (let cy = 0, n = max(ly, hasAlpha ? 5 : 3); cy < n; cy++) fy[cy] = cos(PI / h * (y + 0.5) * cy);\n\n      // Decode L\n      for (let cy = 0, j = 0; cy < ly; cy++) for (let cx = cy ? 0 : 1, fy2 = fy[cy] * 2; cx * ly < lx * (ly - cy); cx++, j++) l += l_ac[j] * fx[cx] * fy2;\n\n      // Decode P and Q\n      for (let cy = 0, j = 0; cy < 3; cy++) {\n        for (let cx = cy ? 0 : 1, fy2 = fy[cy] * 2; cx < 3 - cy; cx++, j++) {\n          let f = fx[cx] * fy2;\n          p += p_ac[j] * f;\n          q += q_ac[j] * f;\n        }\n      }\n\n      // Decode A\n      if (hasAlpha) for (let cy = 0, j = 0; cy < 5; cy++) for (let cx = cy ? 0 : 1, fy2 = fy[cy] * 2; cx < 5 - cy; cx++, j++) a += a_ac[j] * fx[cx] * fy2;\n\n      // Convert to RGB\n      let b = l - 2 / 3 * p;\n      let r = (3 * l - b + q) / 2;\n      let g = r - q;\n      rgba[i] = max(0, 255 * min(1, r));\n      rgba[i + 1] = max(0, 255 * min(1, g));\n      rgba[i + 2] = max(0, 255 * min(1, b));\n      rgba[i + 3] = max(0, 255 * min(1, a));\n    }\n  }\n  return {\n    w,\n    h,\n    rgba\n  };\n}\n\n/**\n * Extracts the average color from a ThumbHash. RGB is not be premultiplied by A.\n *\n * @param hash The bytes of the ThumbHash.\n * @returns The RGBA values for the average color. Each value ranges from 0 to 1.\n */\nexport function thumbHashToAverageRGBA(hash) {\n  let {\n    min,\n    max\n  } = Math;\n  let header = hash[0] | hash[1] << 8 | hash[2] << 16;\n  let l = (header & 63) / 63;\n  let p = (header >> 6 & 63) / 31.5 - 1;\n  let q = (header >> 12 & 63) / 31.5 - 1;\n  let hasAlpha = header >> 23;\n  let a = hasAlpha ? (hash[5] & 15) / 15 : 1;\n  let b = l - 2 / 3 * p;\n  let r = (3 * l - b + q) / 2;\n  let g = r - q;\n  return {\n    r: max(0, min(1, r)),\n    g: max(0, min(1, g)),\n    b: max(0, min(1, b)),\n    a\n  };\n}\n\n/**\n * Extracts the approximate aspect ratio of the original image.\n *\n * @param hash The bytes of the ThumbHash.\n * @returns The approximate aspect ratio (i.e. width / height).\n */\nexport function thumbHashToApproximateAspectRatio(hash) {\n  let header = hash[3];\n  let hasAlpha = hash[2] & 0x80;\n  let isLandscape = hash[4] & 0x80;\n  let lx = isLandscape ? hasAlpha ? 5 : 7 : header & 7;\n  let ly = isLandscape ? header & 7 : hasAlpha ? 5 : 7;\n  return lx / ly;\n}\n\n/**\n * Encodes an RGBA image to a PNG data URL. RGB should not be premultiplied by\n * A. This is optimized for speed and simplicity and does not optimize for size\n * at all. This doesn't do any compression (all values are stored uncompressed).\n *\n * @param w The width of the input image. Must be ≤100px.\n * @param h The height of the input image. Must be ≤100px.\n * @param rgba The pixels in the input image, row-by-row. Must have w*h*4 elements.\n * @returns A data URL containing a PNG for the input image.\n */\nexport function rgbaToDataURL(w, h, rgba) {\n  let row = w * 4 + 1;\n  let idat = 6 + h * (5 + row);\n  let bytes = [137, 80, 78, 71, 13, 10, 26, 10, 0, 0, 0, 13, 73, 72, 68, 82, 0, 0, w >> 8, w & 255, 0, 0, h >> 8, h & 255, 8, 6, 0, 0, 0, 0, 0, 0, 0, idat >>> 24, idat >> 16 & 255, idat >> 8 & 255, idat & 255, 73, 68, 65, 84, 120, 1];\n  let table = [0, 498536548, 997073096, 651767980, 1994146192, 1802195444, 1303535960, 1342533948, -306674912, -267414716, -690576408, -882789492, -1687895376, -2032938284, -1609899400, -1111625188];\n  let a = 1,\n    b = 0;\n  for (let y = 0, i = 0, end = row - 1; y < h; y++, end += row - 1) {\n    bytes.push(y + 1 < h ? 0 : 1, row & 255, row >> 8, ~row & 255, row >> 8 ^ 255, 0);\n    for (b = (b + a) % 65521; i < end; i++) {\n      let u = rgba[i] & 255;\n      bytes.push(u);\n      a = (a + u) % 65521;\n      b = (b + a) % 65521;\n    }\n  }\n  bytes.push(b >> 8, b & 255, a >> 8, a & 255, 0, 0, 0, 0, 0, 0, 0, 0, 73, 69, 78, 68, 174, 66, 96, 130);\n  for (let [start, end] of [[12, 29], [37, 41 + idat]]) {\n    let c = ~0;\n    for (let i = start; i < end; i++) {\n      c ^= bytes[i];\n      c = c >>> 4 ^ table[c & 15];\n      c = c >>> 4 ^ table[c & 15];\n    }\n    c = ~c;\n    bytes[end++] = c >>> 24;\n    bytes[end++] = c >> 16 & 255;\n    bytes[end++] = c >> 8 & 255;\n    bytes[end++] = c & 255;\n  }\n  return 'data:image/png;base64,' + btoa(String.fromCharCode(...bytes));\n}\n\n/**\n * Decodes a ThumbHash to a PNG data URL. This is a convenience function that\n * just calls \"thumbHashToRGBA\" followed by \"rgbaToDataURL\".\n *\n * @param hash The bytes of the ThumbHash.\n * @returns A data URL containing a PNG for the rendered ThumbHash.\n */\nexport function thumbHashToDataURL(hash) {\n  let image = thumbHashToRGBA(hash);\n  return rgbaToDataURL(image.w, image.h, image.rgba);\n}","map":{"version":3,"names":["rgbaToThumbHash","w","h","rgba","Error","PI","round","max","cos","abs","Math","avg_r","avg_g","avg_b","avg_a","i","j","alpha","hasAlpha","l_limit","lx","ly","l","p","q","a","r","g","b","encodeChannel","channel","nx","ny","dc","ac","scale","fx","cy","cx","f","x","y","fy","push","length","l_dc","l_ac","l_scale","p_dc","p_ac","p_scale","q_dc","q_ac","q_scale","a_dc","a_ac","a_scale","isLandscape","header24","header16","hash","ac_start","ac_index","Uint8Array","thumbHashToRGBA","min","decodeChannel","ratio","thumbHashToApproximateAspectRatio","n","fy2","thumbHashToAverageRGBA","header","rgbaToDataURL","row","idat","bytes","table","end","u","start","c","btoa","String","fromCharCode","thumbHashToDataURL","image"],"sources":["/home/yash/UniFix/frontend/node_modules/thumbhash/thumbhash.js"],"sourcesContent":["/**\n * Encodes an RGBA image to a ThumbHash. RGB should not be premultiplied by A.\n *\n * @param w The width of the input image. Must be ≤100px.\n * @param h The height of the input image. Must be ≤100px.\n * @param rgba The pixels in the input image, row-by-row. Must have w*h*4 elements.\n * @returns The ThumbHash as a Uint8Array.\n */\nexport function rgbaToThumbHash(w, h, rgba) {\n  // Encoding an image larger than 100x100 is slow with no benefit\n  if (w > 100 || h > 100) throw new Error(`${w}x${h} doesn't fit in 100x100`)\n  let { PI, round, max, cos, abs } = Math\n\n  // Determine the average color\n  let avg_r = 0, avg_g = 0, avg_b = 0, avg_a = 0\n  for (let i = 0, j = 0; i < w * h; i++, j += 4) {\n    let alpha = rgba[j + 3] / 255\n    avg_r += alpha / 255 * rgba[j]\n    avg_g += alpha / 255 * rgba[j + 1]\n    avg_b += alpha / 255 * rgba[j + 2]\n    avg_a += alpha\n  }\n  if (avg_a) {\n    avg_r /= avg_a\n    avg_g /= avg_a\n    avg_b /= avg_a\n  }\n\n  let hasAlpha = avg_a < w * h\n  let l_limit = hasAlpha ? 5 : 7 // Use fewer luminance bits if there's alpha\n  let lx = max(1, round(l_limit * w / max(w, h)))\n  let ly = max(1, round(l_limit * h / max(w, h)))\n  let l = [] // luminance\n  let p = [] // yellow - blue\n  let q = [] // red - green\n  let a = [] // alpha\n\n  // Convert the image from RGBA to LPQA (composite atop the average color)\n  for (let i = 0, j = 0; i < w * h; i++, j += 4) {\n    let alpha = rgba[j + 3] / 255\n    let r = avg_r * (1 - alpha) + alpha / 255 * rgba[j]\n    let g = avg_g * (1 - alpha) + alpha / 255 * rgba[j + 1]\n    let b = avg_b * (1 - alpha) + alpha / 255 * rgba[j + 2]\n    l[i] = (r + g + b) / 3\n    p[i] = (r + g) / 2 - b\n    q[i] = r - g\n    a[i] = alpha\n  }\n\n  // Encode using the DCT into DC (constant) and normalized AC (varying) terms\n  let encodeChannel = (channel, nx, ny) => {\n    let dc = 0, ac = [], scale = 0, fx = []\n    for (let cy = 0; cy < ny; cy++) {\n      for (let cx = 0; cx * ny < nx * (ny - cy); cx++) {\n        let f = 0\n        for (let x = 0; x < w; x++)\n          fx[x] = cos(PI / w * cx * (x + 0.5))\n        for (let y = 0; y < h; y++)\n          for (let x = 0, fy = cos(PI / h * cy * (y + 0.5)); x < w; x++)\n            f += channel[x + y * w] * fx[x] * fy\n        f /= w * h\n        if (cx || cy) {\n          ac.push(f)\n          scale = max(scale, abs(f))\n        } else {\n          dc = f\n        }\n      }\n    }\n    if (scale)\n      for (let i = 0; i < ac.length; i++)\n        ac[i] = 0.5 + 0.5 / scale * ac[i]\n    return [dc, ac, scale]\n  }\n  let [l_dc, l_ac, l_scale] = encodeChannel(l, max(3, lx), max(3, ly))\n  let [p_dc, p_ac, p_scale] = encodeChannel(p, 3, 3)\n  let [q_dc, q_ac, q_scale] = encodeChannel(q, 3, 3)\n  let [a_dc, a_ac, a_scale] = hasAlpha ? encodeChannel(a, 5, 5) : []\n\n  // Write the constants\n  let isLandscape = w > h\n  let header24 = round(63 * l_dc) | (round(31.5 + 31.5 * p_dc) << 6) | (round(31.5 + 31.5 * q_dc) << 12) | (round(31 * l_scale) << 18) | (hasAlpha << 23)\n  let header16 = (isLandscape ? ly : lx) | (round(63 * p_scale) << 3) | (round(63 * q_scale) << 9) | (isLandscape << 15)\n  let hash = [header24 & 255, (header24 >> 8) & 255, header24 >> 16, header16 & 255, header16 >> 8]\n  let ac_start = hasAlpha ? 6 : 5\n  let ac_index = 0\n  if (hasAlpha) hash.push(round(15 * a_dc) | (round(15 * a_scale) << 4))\n\n  // Write the varying factors\n  for (let ac of hasAlpha ? [l_ac, p_ac, q_ac, a_ac] : [l_ac, p_ac, q_ac])\n    for (let f of ac)\n      hash[ac_start + (ac_index >> 1)] |= round(15 * f) << ((ac_index++ & 1) << 2)\n  return new Uint8Array(hash)\n}\n\n/**\n * Decodes a ThumbHash to an RGBA image. RGB is not be premultiplied by A.\n *\n * @param hash The bytes of the ThumbHash.\n * @returns The width, height, and pixels of the rendered placeholder image.\n */\nexport function thumbHashToRGBA(hash) {\n  let { PI, min, max, cos, round } = Math\n\n  // Read the constants\n  let header24 = hash[0] | (hash[1] << 8) | (hash[2] << 16)\n  let header16 = hash[3] | (hash[4] << 8)\n  let l_dc = (header24 & 63) / 63\n  let p_dc = ((header24 >> 6) & 63) / 31.5 - 1\n  let q_dc = ((header24 >> 12) & 63) / 31.5 - 1\n  let l_scale = ((header24 >> 18) & 31) / 31\n  let hasAlpha = header24 >> 23\n  let p_scale = ((header16 >> 3) & 63) / 63\n  let q_scale = ((header16 >> 9) & 63) / 63\n  let isLandscape = header16 >> 15\n  let lx = max(3, isLandscape ? hasAlpha ? 5 : 7 : header16 & 7)\n  let ly = max(3, isLandscape ? header16 & 7 : hasAlpha ? 5 : 7)\n  let a_dc = hasAlpha ? (hash[5] & 15) / 15 : 1\n  let a_scale = (hash[5] >> 4) / 15\n\n  // Read the varying factors (boost saturation by 1.25x to compensate for quantization)\n  let ac_start = hasAlpha ? 6 : 5\n  let ac_index = 0\n  let decodeChannel = (nx, ny, scale) => {\n    let ac = []\n    for (let cy = 0; cy < ny; cy++)\n      for (let cx = cy ? 0 : 1; cx * ny < nx * (ny - cy); cx++)\n        ac.push((((hash[ac_start + (ac_index >> 1)] >> ((ac_index++ & 1) << 2)) & 15) / 7.5 - 1) * scale)\n    return ac\n  }\n  let l_ac = decodeChannel(lx, ly, l_scale)\n  let p_ac = decodeChannel(3, 3, p_scale * 1.25)\n  let q_ac = decodeChannel(3, 3, q_scale * 1.25)\n  let a_ac = hasAlpha && decodeChannel(5, 5, a_scale)\n\n  // Decode using the DCT into RGB\n  let ratio = thumbHashToApproximateAspectRatio(hash)\n  let w = round(ratio > 1 ? 32 : 32 * ratio)\n  let h = round(ratio > 1 ? 32 / ratio : 32)\n  let rgba = new Uint8Array(w * h * 4), fx = [], fy = []\n  for (let y = 0, i = 0; y < h; y++) {\n    for (let x = 0; x < w; x++, i += 4) {\n      let l = l_dc, p = p_dc, q = q_dc, a = a_dc\n\n      // Precompute the coefficients\n      for (let cx = 0, n = max(lx, hasAlpha ? 5 : 3); cx < n; cx++)\n        fx[cx] = cos(PI / w * (x + 0.5) * cx)\n      for (let cy = 0, n = max(ly, hasAlpha ? 5 : 3); cy < n; cy++)\n        fy[cy] = cos(PI / h * (y + 0.5) * cy)\n\n      // Decode L\n      for (let cy = 0, j = 0; cy < ly; cy++)\n        for (let cx = cy ? 0 : 1, fy2 = fy[cy] * 2; cx * ly < lx * (ly - cy); cx++, j++)\n          l += l_ac[j] * fx[cx] * fy2\n\n      // Decode P and Q\n      for (let cy = 0, j = 0; cy < 3; cy++) {\n        for (let cx = cy ? 0 : 1, fy2 = fy[cy] * 2; cx < 3 - cy; cx++, j++) {\n          let f = fx[cx] * fy2\n          p += p_ac[j] * f\n          q += q_ac[j] * f\n        }\n      }\n\n      // Decode A\n      if (hasAlpha)\n        for (let cy = 0, j = 0; cy < 5; cy++)\n          for (let cx = cy ? 0 : 1, fy2 = fy[cy] * 2; cx < 5 - cy; cx++, j++)\n            a += a_ac[j] * fx[cx] * fy2\n\n      // Convert to RGB\n      let b = l - 2 / 3 * p\n      let r = (3 * l - b + q) / 2\n      let g = r - q\n      rgba[i] = max(0, 255 * min(1, r))\n      rgba[i + 1] = max(0, 255 * min(1, g))\n      rgba[i + 2] = max(0, 255 * min(1, b))\n      rgba[i + 3] = max(0, 255 * min(1, a))\n    }\n  }\n  return { w, h, rgba }\n}\n\n/**\n * Extracts the average color from a ThumbHash. RGB is not be premultiplied by A.\n *\n * @param hash The bytes of the ThumbHash.\n * @returns The RGBA values for the average color. Each value ranges from 0 to 1.\n */\nexport function thumbHashToAverageRGBA(hash) {\n  let { min, max } = Math\n  let header = hash[0] | (hash[1] << 8) | (hash[2] << 16)\n  let l = (header & 63) / 63\n  let p = ((header >> 6) & 63) / 31.5 - 1\n  let q = ((header >> 12) & 63) / 31.5 - 1\n  let hasAlpha = header >> 23\n  let a = hasAlpha ? (hash[5] & 15) / 15 : 1\n  let b = l - 2 / 3 * p\n  let r = (3 * l - b + q) / 2\n  let g = r - q\n  return {\n    r: max(0, min(1, r)),\n    g: max(0, min(1, g)),\n    b: max(0, min(1, b)),\n    a\n  }\n}\n\n/**\n * Extracts the approximate aspect ratio of the original image.\n *\n * @param hash The bytes of the ThumbHash.\n * @returns The approximate aspect ratio (i.e. width / height).\n */\nexport function thumbHashToApproximateAspectRatio(hash) {\n  let header = hash[3]\n  let hasAlpha = hash[2] & 0x80\n  let isLandscape = hash[4] & 0x80\n  let lx = isLandscape ? hasAlpha ? 5 : 7 : header & 7\n  let ly = isLandscape ? header & 7 : hasAlpha ? 5 : 7\n  return lx / ly\n}\n\n/**\n * Encodes an RGBA image to a PNG data URL. RGB should not be premultiplied by\n * A. This is optimized for speed and simplicity and does not optimize for size\n * at all. This doesn't do any compression (all values are stored uncompressed).\n *\n * @param w The width of the input image. Must be ≤100px.\n * @param h The height of the input image. Must be ≤100px.\n * @param rgba The pixels in the input image, row-by-row. Must have w*h*4 elements.\n * @returns A data URL containing a PNG for the input image.\n */\nexport function rgbaToDataURL(w, h, rgba) {\n  let row = w * 4 + 1\n  let idat = 6 + h * (5 + row)\n  let bytes = [\n    137, 80, 78, 71, 13, 10, 26, 10, 0, 0, 0, 13, 73, 72, 68, 82, 0, 0,\n    w >> 8, w & 255, 0, 0, h >> 8, h & 255, 8, 6, 0, 0, 0, 0, 0, 0, 0,\n    idat >>> 24, (idat >> 16) & 255, (idat >> 8) & 255, idat & 255,\n    73, 68, 65, 84, 120, 1\n  ]\n  let table = [\n    0, 498536548, 997073096, 651767980, 1994146192, 1802195444, 1303535960,\n    1342533948, -306674912, -267414716, -690576408, -882789492, -1687895376,\n    -2032938284, -1609899400, -1111625188\n  ]\n  let a = 1, b = 0\n  for (let y = 0, i = 0, end = row - 1; y < h; y++, end += row - 1) {\n    bytes.push(y + 1 < h ? 0 : 1, row & 255, row >> 8, ~row & 255, (row >> 8) ^ 255, 0)\n    for (b = (b + a) % 65521; i < end; i++) {\n      let u = rgba[i] & 255\n      bytes.push(u)\n      a = (a + u) % 65521\n      b = (b + a) % 65521\n    }\n  }\n  bytes.push(\n    b >> 8, b & 255, a >> 8, a & 255, 0, 0, 0, 0,\n    0, 0, 0, 0, 73, 69, 78, 68, 174, 66, 96, 130\n  )\n  for (let [start, end] of [[12, 29], [37, 41 + idat]]) {\n    let c = ~0\n    for (let i = start; i < end; i++) {\n      c ^= bytes[i]\n      c = (c >>> 4) ^ table[c & 15]\n      c = (c >>> 4) ^ table[c & 15]\n    }\n    c = ~c\n    bytes[end++] = c >>> 24\n    bytes[end++] = (c >> 16) & 255\n    bytes[end++] = (c >> 8) & 255\n    bytes[end++] = c & 255\n  }\n  return 'data:image/png;base64,' + btoa(String.fromCharCode(...bytes))\n}\n\n/**\n * Decodes a ThumbHash to a PNG data URL. This is a convenience function that\n * just calls \"thumbHashToRGBA\" followed by \"rgbaToDataURL\".\n *\n * @param hash The bytes of the ThumbHash.\n * @returns A data URL containing a PNG for the rendered ThumbHash.\n */\nexport function thumbHashToDataURL(hash) {\n  let image = thumbHashToRGBA(hash)\n  return rgbaToDataURL(image.w, image.h, image.rgba)\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}